

Analisis aStar:
    el A* me devuelve una lista de nodos del tileMap, que es el camino mas corto.
    PERO:
    yo necesito eso en la posicion del Layer
    
    El Layer tiene el TileMap asignado, por lo tanto tiene acceso a A*.
    y los Sprites tienen una referencia al Layer en el que estan 
    por lo tanto 
    Sprite.go(node) -> Obtiene un Path, que lo arma Layer, con A* de TileMap...
    
    Si un Sprite esta en un Layer que tiene un TileMap, entonces podra utilizar A*
    
    Podria aceptar:
        Node: Posicion X,Y del layer
        Sprite: obtiene la posicion X,Y del Sprite que le paso.
        
    y cuando termina... deberia poder ejecutarse un callback, que seria el callback del Path...
    y que ese callback... no se... recalcule... 
    ANALIZAR MAS DESPIERTO
    
    


CONTINUAR CON DOCUMENTACION: Tween, Path


aStar en TileMap, que sera llamada desde otra funcion, en sprite o donde sea...

aStar : function(nIni, nFin)

esta funcion me devuelve una lista de puntos que es el recorrido... despues esta lista la tendre que pasar a coordenadas x,y. y armar el path con ella. 

if nIni = nFin 
    retorno nIni como solucion.
else 
    listaAbierta.add(nIni)
    while (listaAbierta.length > 0)
        nodo = listaAbierta.getMinCost()
        if(nodo = nFin)
            retorno listaCerrada
        else 
            listaAbierta.remove(nodo)
            listaCerrada.add(nodo)
            nearNodes[] = TileMap.getNearNodes(nodo)   // esto obtiene nodos vecinos, NO SOLIDOS
            each(nearNodes as nearNode)
                if(!listaCerrada.hasNode(nearNode)) 
                    listaAbierta.add(nearNode, true) // sobreescribo si tiene costo menor

    end while
    
    si llega a este punto, entonces no encontro un camino... retornara null.

    
en TileMap: 
 
getNearNodes(node): metodo, que obtenga una lista de nodos adyacentes. ver de considerar cuando puedo obtener los nodos en diagonal. debe devolver una lista de nodos {x,y, costo}

privado??? 
_calcCost(n1,n2): calcula la distancia de Manhattan entre los 2 nodos.

n = 4
0   0
[   ]

n = 8
0   1
[   ]
4





modificar el preloader, para que precargue cualquier cosa (entre esas cosas, los maps)


    
     







en Sprite, poner algo que ignore el boundary

en Sprite, ver si cuando hago destroy lo remueve del layer...

implementar en TileMap dos funciones: hasLayer y hasBoundary... ya que lo necesitar√© en Layer, para ver si, cuando asigno un tilemap a un layer saber que mapas tiene el TileMap

ARREGLAR E IMPLEMENTAR EN LAYER
poder especificar un color de background (negro por defecto) para el caso en que ponga un setBackground que sea transparente...
ese color sera el que se pintara en class.layer.js L68.











luego implementar aStar

En TileMap: si no se especifica width o height tomar del canvas. (copiar lo que esta en Layer)
    
    


TODO:

    Corregir la parte en que toca la animacion de fin... ver los valores de speed y testear a bajas velocidades, para
    corroborar que esta haciendo bien... para SI esta bien, pero para otros games seguramente sera problematico.
    
ANTES DE SEGUIR CON LO DEMAS, DOCUMENTAR Y COMENTAR.    


Colisiones: 
    - agregar una propiedad que sea collisionPadding, en la que pueda especificar la cantidad de pixeles hacia adentro para restar
a la formula de colision
    - Agregar el tipo de colision que deseo detectar, si por boxes o por circles
    - Optimizar: que solo detecte probables candidatos. VER COMO.


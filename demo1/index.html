<html>
    <head>
        <!-- libs -->
        <script src="../js/underscore.js"></script> 
        <!-- main lib -->
        <script src="../js/orange2.js"></script> 
        <!-- classes -->
        <script src="../js/class.layer.js"></script> 
        <script src="../js/class.image_manager.js"></script> 
        <script src="../js/class.image_map.js"></script> 
        <script src="../js/class.sprite.js"></script> 
        <script src="../js/class.animation.js"></script> 
        
</head>

    <body>
        <canvas id="main" width="256" height="224" style="background-color: black"></canvas>
        <br />
        cursores para mover, Control Izquierdo para disparar
    </body>
    
<script>
    // basura global
    var nave, 
        
        x=0, 
        y=0, 
        dx=0, 
        dy=0;
        
    var global = {};
    global.enemyDx = 1;
    global.downCounter = 0;
    global.changeDir = false; 
    
        
    // Primero que nada: inicializar la libreria
    Orange.init(document.getElementById("main"));
    
    // agrego las imagenes que quiero utilizar.
    Orange.getImageManager().addImage(["img/bala_enemy.png", 
        "img/enemy1.png", 
        "img/enemy2.png", 
        "img/enemy3.png", 
        "img/ufo.png", 
        "img/nave.png", 
        "img/bala_nave.png", 
        "img/borrar/screenShotSI.png"
    ]);
    
    
    
    // Inicio la precarga, cuando finalize llama al callback.
    // mas adelante tengo que hacerlo mejor, con un objeto que tenga sucess, error, progress, etc.
    Orange.getImageManager().preload(function(){

        // Layers
        var l = new Orange.Layer();
        Orange.addLayer(l);
        l.setBackground(Orange.getImageManager().get("screenShotSI"))


        
        
        // Definicion de Nave -------------------------
        // ImageMaps
        var naveImageMap = new Orange.ImageMap({
            image : Orange.getImageManager().get("nave"),
            width : 16,
            height : 8,
            dieStatus : 1 // el status que seleccionara al momento de hacer destroy en el sprite
        });
        
        // Animations
        var naveAnimation = new Orange.Animation(naveImageMap, {
            statusConfig : [ 
                { loopMode : "L"},
                { loopMode : "L"}
            ],
            speed : 1
        });

        // Nave Sprite
        nave = new Orange.Sprite({
            src : naveAnimation,
            speed : 1,
            class : Orange.Sprite.Classes.FRIEND
        });
        
        l.addSprite(nave); 
        nave.setX(110).setY(192);

        // Bind
        nave.on("keydown", function(eventData, s) {
            switch(eventData.e.keyCode) {
                case 39 :   dx = 2 * s.getSpeed();
                            break;
                case 37 :   dx = 2 * -s.getSpeed();
                            break;
                case 17 :   var spr = new Shot(s.getX() + 8, s.getY());
                            break;
                default :   console.log(eventData.e.keyCode);
            }
            
        });

        nave.on("keyup", function(eventData, s) {
            switch(eventData.e.keyCode) {
                case 39 :   dx = 0;
                            break;
                case 37 :   dx = 0;
                            break;
            }
        });
        
        
        
        
        
        
        
        
        // Definicion del tiro de la nave ---------------------------------------
        var balaEnemyImageMap = new Orange.ImageMap({
            image : Orange.getImageManager().get("bala_nave"), 
            width : 1,
            height : 4
        });
        
        // esto es asi, para despues hacer new, new new ... es un pequeÃ±o constructor de tiros.
        var Shot = function(x,y) {
            var spr = new Orange.Sprite({
                src : balaEnemyImageMap
            });
            
            l.addSprite(spr);
            spr.setX(x).setY(y);
            
            spr.on("enterFrame", function(eventData, s) { 
                if (s.getY() > 10) {
                    s.incY(-4);
                } else {
                    s.destroy();
                }
            });            
            
            spr.on("collision", function(eventName, context, aCollision) {
                if(aCollision.length > 0) {
                    if(aCollision[0].getClass() == Orange.Sprite.Classes.ENEMY) {
                        aCollision[0].destroy();
                        context.destroy();
                    }
                }
            });
            
            return spr;
        }
             
             
             
             
        // Definicion de enemigos --------------------------------
        var enemy3ImageMap = new Orange.ImageMap({
            image : Orange.getImageManager().get("enemy3"), 
            width : 10,
            height : 8,
            dieStatus : 1
        });
        
        var enemy2ImageMap = new Orange.ImageMap({
            image : Orange.getImageManager().get("enemy2"), 
            width : 13,
            height : 8,
            dieStatus : 1
        });
        
        var enemy1ImageMap = new Orange.ImageMap({
            image : Orange.getImageManager().get("enemy1"), 
            width : 14,
            height : 8,
            dieStatus : 1
        });
             
             
             
        // creo las filas de enemigos
        for(var i=0; i<11; i++) {
            var enemy3Animation = new Orange.Animation(enemy3ImageMap, {
                statusConfig : [ 
                    { loopMode : "L"},
                    { loopMode : "L", speed : 2}
                ],
                speed : 8
            });
        
            var enemy3 = new Orange.Sprite({
                src : enemy3Animation,
                class : Orange.Sprite.Classes.ENEMY
            });
            l.addSprite(enemy3); 
            
            enemy3.setX(i*16 + 49).setY(40);

            // enterFrame. -----------------------------------------------------------------
            enemy3.on("enterFrame", function(eventData, s) { 
                    s.incX(global.enemyDx);
                    
                    if(((s.getX() < 0) || (s.getX() > 240))&& (!global.changeDir)) {
                        global.changeDir = true; 
                    } 
                    
                    if(global.downCounter > 0) {
                        s.incY(1);
                    }
            });
            
            // colision enemigo-nave. -----------------------------------------------------------------
            enemy3.on("collision", function(eventData, s, aCollision) { 
                if(aCollision.length > 0) {
                    if(aCollision[0].getClass() == Orange.Sprite.Classes.FRIEND) {
                        aCollision[0].destroy(false);
                    }
                }
            });
            
        }

        
        
        for(var j=0; j<2; j++) {
            for(var i=0; i<11; i++) {
            
                var enemy2Animation = new Orange.Animation(enemy2ImageMap, {
                    statusConfig : [ 
                        { loopMode : "L"},
                        { loopMode : "L", speed : 2}
                    ],
                    speed : 8
                });
            
                var enemy2 = new Orange.Sprite({
                    src : enemy2Animation,
                    class : Orange.Sprite.Classes.ENEMY
                });
                l.addSprite(enemy2); 
                
                enemy2.setX(i*16 + 49).setY(56 + j*16);

                // enterFrame. -----------------------------------------------------------------
                enemy2.on("enterFrame", function(eventData, s) { 
                    s.incX(global.enemyDx);
                    
                    if(((s.getX() < 0) || (s.getX() > 240))&& (!global.changeDir)) {
                        global.changeDir = true; 
                    }
                    
                    if(global.downCounter > 0) s.incY(1);
                });
                
                
                // colision enemigo-nave.-----------------------------------------------------------------
                enemy2.on("collision", function(eventData, s, aCollision) { 
                    if(aCollision.length > 0) {
                        if(aCollision[0].getClass() == Orange.Sprite.Classes.FRIEND) {
                            aCollision[0].destroy(false);
                        }
                    }
                });
                
            }
        }


        for(var j=0; j<2; j++) {
            for(var i=0; i<11; i++) {
            
                var enemy1Animation = new Orange.Animation(enemy1ImageMap, {
                    statusConfig : [ 
                        { loopMode : "L"},
                        { loopMode : "L", speed : 2}
                    ],
                    speed : 8
                });
            
                var enemy1 = new Orange.Sprite({
                    src : enemy1Animation,
                    class : Orange.Sprite.Classes.ENEMY
                });
                
                l.addSprite(enemy1); 
                
                // posicionamiento enemigos
                enemy1.setX(i*16 + 49).setY(88 + j*16);
                
                // Bindings enemys -----------------------------------------------------------------
                // SIEMPRE es necesario agregar primero el sprite antes de asignarle algun evento
                enemy1.on("enterFrame", function(eventData, s) { 
                    s.incX(global.enemyDx);
                    
                    if(((s.getX() < 0) || (s.getX() > 240))&& (!global.changeDir)) {
                        global.changeDir = true; 
                    }
                    
                    if(global.downCounter > 0) {
                        s.incY(1);
                    }                    
                });
                
                
                // colision enemigo-nave.-----------------------------------------------------------------
                enemy1.on("collision", function(eventData, s, aCollision) { 
                    if(aCollision.length > 0) {
                        if(aCollision[0].getClass() == Orange.Sprite.Classes.FRIEND) {
                            aCollision[0].destroy(false);
                        }
                    }
                });
                
            }

        }
        
        
        
        // especifico el bucle principal, este se ejecutara 60 veces por segundo.
        // esto reescribirlo como un evento, mejor
        // algo asi como Orange.onUpdate... lalala
        Orange.setMainCallback(function() {
            nave.incX(dx); // hack pedorro para que la nave se mueva... mejorar esta mierda.
            // este callback inmundo no deberia ser necesario, solo para algunas pelotudeces...
            
            // ya se actualizo, y si se cambio de direccion no lo necesito mas... lo vuelvo a false
            if(global.changeDir) { 
                global.enemyDx = -global.enemyDx;
                global.downCounter = 14;
                global.changeDir = false;
            }
            
            if(global.downCounter > 0) global.downCounter--;
            
        });
        
        // Inicio la ejecucion del bucle.
        Orange.start();
        //Orange.stop();
    }); // preload
    

    
</script>
</hmtl>